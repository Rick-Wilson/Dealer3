// Dealer constraint language grammar

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{
    ("#" ~ (!"\n" ~ ANY)*) |
    ("//" ~ (!"\n" ~ ANY)*) |
    ("/*" ~ (!"*/" ~ ANY)* ~ "*/")
}

// Top-level can be a dealer program with action blocks or simple statements
// Statements can be separated by newlines, semicolons, or commas (for action lists)
program = { SOI ~ (dealer_statement ~ ("\n" | ";" | ",")?)* ~ EOI }

// Dealer statement types
dealer_statement = {
    condition_stmt
    | produce_stmt
    | action_stmt
    | dealer_stmt
    | vulnerable_stmt
    | predeal_stmt
    | csvrpt_stmt
    | average_stmt
    | frequency_stmt
    | print_stmt
    | assignment
    | expr
}

// Standalone action statements (can appear without "action" keyword)
average_stmt = { ^"average" ~ string_literal? ~ expr }
frequency_stmt = { ^"frequency" ~ string_literal? ~ "(" ~ expr ~ "," ~ literal ~ "," ~ literal ~ ")" }
print_stmt = { ^"printall" | ^"printew" | ^"printpbn" | ^"printcompact" | ^"printoneline" }

// Action block keywords
condition_stmt = { ^"condition" ~ expr }
produce_stmt = { ^"produce" ~ literal }
action_stmt = { ^"action" ~ action_component ~ ("," ~ action_component)* }
dealer_stmt = { ^"dealer" ~ compass }
vulnerable_stmt = { ^"vulnerable" ~ vulnerability }
predeal_stmt = { ^"predeal" ~ compass ~ predeal_card ~ ("," ~ predeal_card)* }
csvrpt_stmt = { ^"csvrpt" ~ "(" ~ csv_term ~ ("," ~ csv_term)* ~ ")" }

// CSV terms for csvrpt
csv_term = {
    ^"deal" |
    side |
    compass |
    string_literal |
    expr
}

side = @{ ^"ns" | ^"ew" }

// Action components (can be comma-separated)
action_component = { average_spec | frequency_spec | action_type }
average_spec = { ^"average" ~ string_literal? ~ expr }
// frequency "label" (expr, min, max) - parentheses with commas
frequency_spec = { ^"frequency" ~ string_literal? ~ "(" ~ expr ~ "," ~ literal ~ "," ~ literal ~ ")" }

action_type = @{
    ^"printall" | ^"printew" | ^"printpbn" | ^"printcompact" | ^"printoneline"
}

// Dealer position (compass)
compass = @{
    (^"north" | ^"south" | ^"east" | ^"west") ~ !(ASCII_ALPHANUMERIC | "_")
    | (^"n" | ^"s" | ^"e" | ^"w") ~ !(ASCII_ALPHANUMERIC | "_")
}

// Vulnerability values
vulnerability = @{
    ^"none" | ^"ns" | ^"ew" | ^"all"
}

// Variable assignment - uses assign_ident which allows single letters like s, n, e, w
assignment = { assign_ident ~ "=" ~ expr }

// Identifier for left side of assignment (allows single letters that would otherwise match positions)
assign_ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Top-level constraint expression (for backward compatibility)
constraint = { SOI ~ expr ~ EOI }

// Expressions with operator precedence
// Ternary has lowest precedence
expr = { ternary }

ternary = { logical_or ~ ("?" ~ logical_or ~ ":" ~ ternary)? }

logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { logical_not ~ (and_op ~ logical_not)* }
logical_not = { not_op ~ logical_not | comparison }

// Logical operator keywords
// Use @{} atomic rules with negative lookahead to ensure keywords are not part of a variable name
// e.g., "notNT" should be parsed as a variable, not "not" followed by "NT"
or_op = { "||" | or_keyword }
and_op = { "&&" | and_keyword }
not_op = { "!" | not_keyword }

or_keyword = @{ ^"or" ~ !(ASCII_ALPHANUMERIC | "_") }
and_keyword = @{ ^"and" ~ !(ASCII_ALPHANUMERIC | "_") }
not_keyword = @{ ^"not" ~ !(ASCII_ALPHANUMERIC | "_") }

comparison = { additive ~ (cmp_op ~ additive)? }
additive = { multiplicative ~ (add_op ~ multiplicative)* }
multiplicative = { unary ~ (mul_op ~ unary)* }
// Unary operators: negation (-) and logical not (!/not)
// Both have the same (high) precedence, so 100 * not x = 100 * (not x)
unary = { "-" ~ unary | not_op ~ unary | primary }

primary = _{
    function_call  // Must be first to parse function(args)
    | paren_expr
    | shape_pattern
    | card
    | suit  // Suit keywords (spades, hearts, etc) as standalone values
    | position
    | literal
    | ident  // Variable references (must be last to avoid conflicts)
}

paren_expr = { "(" ~ expr ~ ")" }

// Function calls: hcp(north), hearts(south,spades), hascard(south,AS)
function_call = { function_name ~ "(" ~ expr ~ ("," ~ expr)* ~ ")" }

function_name = @{
    "hcp" | "controls" | "losers" | "loser"
    | "shape" | "hascard"
    | "tens" | "jacks" | "queens" | "kings" | "aces"
    | "top2" | "top3" | "top4" | "top5" | "c13"
    | "pt0" | "pt1" | "pt2" | "pt3" | "pt4" | "pt5" | "pt6" | "pt7" | "pt8" | "pt9"
    | "quality" | "cccc"
    | "tricks" | "score" | "imps"  // Double-dummy and scoring functions
    | "hearts" | "spades" | "diamonds" | "clubs"  // Plural forms (must be before singular)
    | "heart" | "spade" | "diamond" | "club"  // Singular aliases
}

// Comparison operators
cmp_op = {
    "==" | "!=" | "<=" | ">=" | "<" | ">"
}

// Arithmetic operators
add_op = { "+" | "-" }
mul_op = { "*" | "/" | "%" }

// Positions at the bridge table
// Use word boundary: must not be followed by alphanumeric or underscore
position = @{
    (^"north" | ^"south" | ^"east" | ^"west") ~ !(ASCII_ALPHANUMERIC | "_")
    | (^"n" | ^"s" | ^"e" | ^"w") ~ !(ASCII_ALPHANUMERIC | "_")
}

// Suit names (for functions like losers(north, spades))
// Use negative lookahead to ensure:
// - not followed by '(' (which would be a function call like spades())
// - not followed by alphanumeric (which would be a variable like spadeFit)
suit = @{
    (^"spades" | ^"hearts" | ^"diamonds" | ^"clubs") ~ !(ASCII_ALPHANUMERIC | "(")
}

// Integer literals
literal = @{ "-"? ~ ASCII_DIGIT+ }

// String literals (for average labels)
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Card names for hascard function: AS, KH, 2C (rank + suit)
card = @{
    rank ~ suit_char
}

// Card names for predeal: SA, HKQ, DT62, C95 (suit + one or more ranks)
// dealer.exe predeal uses suit-first format: SA = Ace of Spades, ST62 = Spades T-6-2
predeal_card = @{
    suit_char ~ rank+
}

rank = { "A" | "K" | "Q" | "J" | "T" | "9" | "8" | "7" | "6" | "5" | "4" | "3" | "2" }
suit_char = { "S" | "H" | "D" | "C" }

// Identifiers (for variables)
// Allow any alphanumeric identifier - the parser will try more specific rules first
// Variables like "spadeFit" or "heartCount" must be allowed even though they start with keywords
ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Shape patterns: any 4333 + 54xx - any 0xxx
// Spaces can act as implicit "+" (addition) between shape specs
shape_pattern = { shape_spec ~ ((shape_op)? ~ shape_spec)* }

shape_spec = { (shape_any ~ shape_digits_any) | shape_digits_marked }

shape_any = { ^"any" }

shape_op = { "+" | "-" }

// Shape digits after "any" keyword - can be pure digits (any disambiguates)
shape_digits_any = @{ shape_char ~ shape_char ~ shape_char ~ shape_char }

// Shape digits without "any" - must have %s prefix OR contain wildcards
shape_digits_marked = @{
    ("%s" ~ ASCII_DIGIT ~ ASCII_DIGIT ~ ASCII_DIGIT ~ ASCII_DIGIT)
    | (shape_char_with_wildcard ~ shape_char ~ shape_char ~ shape_char)
    | (shape_char ~ shape_char_with_wildcard ~ shape_char ~ shape_char)
    | (shape_char ~ shape_char ~ shape_char_with_wildcard ~ shape_char)
    | (shape_char ~ shape_char ~ shape_char ~ shape_char_with_wildcard)
}

shape_char = { ASCII_DIGIT | "x" | "X" }
shape_char_with_wildcard = { "x" | "X" }
