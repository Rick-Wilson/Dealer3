// Dealer constraint language grammar

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{
    ("#" ~ (!"\n" ~ ANY)*) |
    ("//" ~ (!"\n" ~ ANY)*) |
    ("/*" ~ (!"*/" ~ ANY)* ~ "*/")
}

// Top-level can be a constraint expression or variable assignment
program = { SOI ~ (statement ~ ("\n" | ";")?)* ~ EOI }
statement = { assignment | expr }
assignment = { ident ~ "=" ~ expr }

// Top-level constraint expression (for backward compatibility)
constraint = { SOI ~ expr ~ EOI }

// Expressions with operator precedence
expr = { logical_or }

logical_or = { logical_and ~ (or_op ~ logical_and)* }
logical_and = { logical_not ~ (and_op ~ logical_not)* }
logical_not = { not_op ~ logical_not | comparison }

// Logical operator keywords
or_op = { "||" | ^"or" }
and_op = { "&&" | ^"and" }
not_op = { "!" | ^"not" }

comparison = { additive ~ (cmp_op ~ additive)? }
additive = { multiplicative ~ (add_op ~ multiplicative)* }
multiplicative = { unary ~ (mul_op ~ unary)* }
unary = { "-" ~ unary | primary }

primary = _{
    function_call  // Must be first to parse function(args)
    | paren_expr
    | shape_pattern
    | card
    | suit  // Suit keywords (spades, hearts, etc) as standalone values
    | position
    | literal
    | ident  // Variable references (must be last to avoid conflicts)
}

paren_expr = { "(" ~ expr ~ ")" }

// Function calls: hcp(north), hearts(south,spades), hascard(south,AS)
function_call = { function_name ~ "(" ~ expr ~ ("," ~ expr)* ~ ")" }

function_name = @{
    "hcp" | "controls" | "losers"
    | "shape" | "hascard"
    | "tens" | "jacks" | "queens" | "kings" | "aces"
    | "top2" | "top3" | "top4" | "top5" | "c13"
    | "pt0" | "pt1" | "pt2" | "pt3" | "pt4" | "pt5" | "pt6" | "pt7" | "pt8" | "pt9"
    | "quality" | "cccc"
    | "hearts" | "spades" | "diamonds" | "clubs"  // Must be after suit check in primary
}

// Comparison operators
cmp_op = {
    "==" | "!=" | "<=" | ">=" | "<" | ">"
}

// Arithmetic operators
add_op = { "+" | "-" }
mul_op = { "*" | "/" | "%" }

// Positions at the bridge table
// Use word boundary: must not be followed by alphanumeric or underscore
position = @{
    (^"north" | ^"south" | ^"east" | ^"west") ~ !(ASCII_ALPHANUMERIC | "_")
    | (^"n" | ^"s" | ^"e" | ^"w") ~ !(ASCII_ALPHANUMERIC | "_")
}

// Suit names (for functions like losers(north, spades))
// Use negative lookahead to ensure not followed by '(' (which would be a function call)
suit = @{
    (^"spades" | ^"hearts" | ^"diamonds" | ^"clubs") ~ !("(")
}

// Integer literals
literal = @{ "-"? ~ ASCII_DIGIT+ }

// Card names: AS, KH, 2C, etc. (rank + suit)
card = @{
    rank ~ suit_char
}

rank = { "A" | "K" | "Q" | "J" | "T" | "9" | "8" | "7" | "6" | "5" | "4" | "3" | "2" }
suit_char = { "S" | "H" | "D" | "C" }

// Identifiers (for variables)
// Must come after position, function_name, and card to avoid conflicts
ident = @{ !(position | function_name) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Shape patterns: any 4333 + 54xx - any 0xxx
shape_pattern = { shape_spec ~ (shape_op ~ shape_spec)* }

shape_spec = { (shape_any ~ shape_digits_any) | shape_digits_marked }

shape_any = { ^"any" }

shape_op = { "+" | "-" }

// Shape digits after "any" keyword - can be pure digits (any disambiguates)
shape_digits_any = @{ shape_char ~ shape_char ~ shape_char ~ shape_char }

// Shape digits without "any" - must have %s prefix OR contain wildcards
shape_digits_marked = @{
    ("%s" ~ ASCII_DIGIT ~ ASCII_DIGIT ~ ASCII_DIGIT ~ ASCII_DIGIT)
    | (shape_char_with_wildcard ~ shape_char ~ shape_char ~ shape_char)
    | (shape_char ~ shape_char_with_wildcard ~ shape_char ~ shape_char)
    | (shape_char ~ shape_char ~ shape_char_with_wildcard ~ shape_char)
    | (shape_char ~ shape_char ~ shape_char ~ shape_char_with_wildcard)
}

shape_char = { ASCII_DIGIT | "x" | "X" }
shape_char_with_wildcard = { "x" | "X" }
